import { useState, useEffect, useRef } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { ethers } from 'ethers';
import { io, Socket } from 'socket.io-client';
import type { ChatMessage, EIP712Data } from '../types/chat';

const BACKEND_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001';

export function useChat() {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const [signer, setSigner] = useState<ethers.Signer | null>(null);
  const [walletAddress, setWalletAddress] = useState<string | null>(null);
  const socketRef = useRef<Socket | null>(null);
  const roomId = useRef(uuidv4());
  
  const signerRef = useRef(signer);
  useEffect(() => {
    signerRef.current = signer;
  }, [signer]);

  // ÏÑúÎ™Ö Ï≤òÎ¶¨ Ìï®Ïàò
  const handleSignMessage = async (dataToSign: EIP712Data) => {
    console.log('[handleSignMessage] ÏÑúÎ™Ö ÏöîÏ≤≠:', dataToSign);
    
    if (!signerRef.current) {
      console.log('[handleSignMessage] Wallet not connected');
      alert('Please connect your wallet first to sign.');
      await connectWallet();
      return;
    }

    try {
      // ÌòÑÏû¨ ÎÑ§Ìä∏ÏõåÌÅ¨ ÌôïÏù∏
      const provider = new ethers.BrowserProvider(window.ethereum!);
      const network = await provider.getNetwork();
      const requiredChainId = BigInt(dataToSign.domain.chainId || 84532);
      
      console.log('[handleSignMessage] ÌòÑÏû¨ ÎÑ§Ìä∏ÏõåÌÅ¨:', network.chainId);
      console.log('[handleSignMessage] ÌïÑÏöîÌïú ÎÑ§Ìä∏ÏõåÌÅ¨:', requiredChainId);
      
      if (network.chainId !== requiredChainId) {
        console.log('[handleSignMessage] ÎÑ§Ìä∏ÏõåÌÅ¨ Î∂àÏùºÏπò, Ï†ÑÌôò ÏöîÏ≤≠');
        const switchSuccess = await switchToBaseNetwork();
        if (!switchSuccess) {
          alert('Please switch to Base Sepolia network.');
          return;
        }
        // ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†ÑÌôò ÌõÑ ÏÉàÎ°úÏö¥ signer ÏÉùÏÑ±
        const newProvider = new ethers.BrowserProvider(window.ethereum!);
        const newSigner = await newProvider.getSigner();
        setSigner(newSigner);
        signerRef.current = newSigner;
      }

      const { domain, types, value } = dataToSign;
      
      console.log('[handleSignMessage] ÏõêÎ≥∏ ÏÑúÎ™Ö Îç∞Ïù¥ÌÑ∞:', { domain, types, value });
      
      // BigInt ÌÉÄÏûÖ Î≥ÄÌôò
      const compatibleDomain = {
        ...domain,
        chainId: BigInt(domain.chainId || 0)
      };
      
      const compatibleValue = {
        ...value,
        amount: BigInt(value.amount || 0),
        nonce: BigInt(value.nonce || 0),
        deadline: BigInt(value.deadline || 0)
      };
      
      console.log('[handleSignMessage] Î©îÌÉÄÎßàÏä§ÌÅ¨ ÏÑúÎ™Ö ÏöîÏ≤≠:', { 
        compatibleDomain, 
        types, 
        compatibleValue 
      });
      
      const signature = await signerRef.current.signTypedData(
        compatibleDomain, 
        types, 
        compatibleValue
      );
      
      console.log('[handleSignMessage] ÏÑúÎ™Ö ÏÑ±Í≥µ:', signature);
      
      // ÏÑúÎ™ÖÏùÑ Î∞±ÏóîÎìúÎ°ú Ï†ÑÏÜ° (ÏõêÎ≥∏ ÏÑúÎ™Ö Îç∞Ïù¥ÌÑ∞ÎèÑ Ìï®Íªò Ï†ÑÏÜ°)
      if (!socketRef.current?.connected) {
        console.log('[handleSignMessage] ÏÜåÏºìÏù¥ Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùå');
        return;
      }

      const signatureMessageData = {
        text: signature,
        roomId: roomId.current,
        userId: walletAddress,
        signature: signature,
        signatureData: {
          domain: domain,
          types: types,
          value: value,
          amount: value.amount,
          nonce: value.nonce,
          deadline: value.deadline
        }
      };

      console.log('[handleSignMessage] ÏÑúÎ™Ö Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ°:', signatureMessageData);
      socketRef.current.emit('message', signatureMessageData);
      
    } catch (error: any) {
      console.error('[handleSignMessage] Signature failed:', error);
      alert(`Signature failed: ${error.message}`);
      sendMessage("Signature was rejected.", false);
    }
  };

  // Î©îÏãúÏßÄÏóêÏÑú ÏÑúÎ™Ö ÏöîÏ≤≠ Í∞êÏßÄ
  useEffect(() => {
    const lastMessage = messages[messages.length - 1];
    if (lastMessage?.isUser === false && 
        lastMessage.action === 'AWAITING_SIGNATURE' && 
        lastMessage.dataToSign) {
      console.log('[useEffect] ÏÑúÎ™Ö ÏöîÏ≤≠ Í∞êÏßÄ, ÏÑúÎ™Ö Ï≤òÎ¶¨ ÏãúÏûë');
      setTimeout(() => handleSignMessage(lastMessage.dataToSign!), 500);
    }
  }, [messages]);

  // ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†ÑÌôò Ìï®Ïàò
  const switchToBaseNetwork = async () => {
    if (typeof window.ethereum === 'undefined') return false;

    try {
      // Base Sepolia ÎÑ§Ìä∏ÏõåÌÅ¨Î°ú Ï†ÑÌôò ÏöîÏ≤≠
      await (window.ethereum as any).request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: '0x14a34' }], // 84532 in hex
      });
      return true;
    } catch (switchError: any) {
      // ÎÑ§Ìä∏ÏõåÌÅ¨Í∞Ä Ï∂îÍ∞ÄÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ Ï∂îÍ∞Ä ÏöîÏ≤≠
      if (switchError.code === 4902) {
        try {
          await (window.ethereum as any).request({
            method: 'wallet_addEthereumChain',
            params: [
              {
                chainId: '0x14a34',
                chainName: 'Base Sepolia',
                nativeCurrency: {
                  name: 'ETH',
                  symbol: 'ETH',
                  decimals: 18,
                },
                rpcUrls: ['https://sepolia.base.org'],
                blockExplorerUrls: ['https://sepolia-explorer.base.org'],
              },
            ],
          });
          return true;
        } catch (addError) {
          console.error('[switchToBaseNetwork] ÎÑ§Ìä∏ÏõåÌÅ¨ Ï∂îÍ∞Ä Ïã§Ìå®:', addError);
          return false;
        }
      }
      console.error('[switchToBaseNetwork] ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†ÑÌôò Ïã§Ìå®:', switchError);
      return false;
    }
  };

  // ÏßÄÍ∞ë Ïó∞Í≤∞
  const connectWallet = async () => {
    if (typeof window.ethereum === 'undefined') {
      console.log('[connectWallet] MetaMask not installed');
      alert('MetaMask is not installed.');
      return;
    }

    try {
      const provider = new ethers.BrowserProvider(window.ethereum);
      const signerInstance = await provider.getSigner();
      const address = await signerInstance.getAddress();
      
      // ÌòÑÏû¨ ÎÑ§Ìä∏ÏõåÌÅ¨ ÌôïÏù∏
      const network = await provider.getNetwork();
      console.log('[connectWallet] ÌòÑÏû¨ ÎÑ§Ìä∏ÏõåÌÅ¨:', network.chainId);
      
      setSigner(signerInstance);
      setWalletAddress(address);
      
      console.log(`[connectWallet] Wallet connected successfully: ${address}`);
      
      // ÎÑ§Ìä∏ÏõåÌÅ¨ ÌôïÏù∏ Î©îÏãúÏßÄ
      let networkMessage = '';
      if (network.chainId !== 84532n) {
        networkMessage = '\n‚ö†Ô∏è Please switch to Base Sepolia network.';
      } else {
        networkMessage = '\n‚úÖ Connected to Base Sepolia network';
      }
      
      // ÏßÄÍ∞ë Ïó∞Í≤∞ ÏÑ±Í≥µ Î©îÏãúÏßÄ Ï∂îÍ∞Ä
      const successMessage: ChatMessage = {
        id: uuidv4(),
        senderName: 'System',
        text: `‚úÖ **Wallet Connected Successfully!**

üìç **Address:** ${address.substring(0, 6)}...${address.substring(38)}${networkMessage}

üéØ **Next Steps:**
1. Check your current collateral: \`status\`
2. Deposit collateral: \`deposit 0.1 eth\`
3. Borrow KK tokens: \`borrow 10 kkcoin\`

üí° **Need help?** Just ask me anything about lending, deposits, or quests!`,
        isUser: false
      };
      
      setMessages(prev => [...prev, successMessage]);
      
    } catch (error) {
      console.error('[connectWallet] Wallet connection failed:', error);
      alert('Failed to connect wallet.');
    }
  };
  
  // Î©îÏãúÏßÄ Ï†ÑÏÜ°
  const sendMessage = (text: string, displayInChat: boolean = true) => {
    console.log('[sendMessage] Î©îÏãúÏßÄ Ï†ÑÏÜ°:', text);
    console.log('[sendMessage] ÌòÑÏû¨ ÏßÄÍ∞ë Ï£ºÏÜå:', walletAddress);
    
    if (!socketRef.current?.connected) {
      console.log('[sendMessage] ÏÜåÏºìÏù¥ Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùå');
      return;
    }

    // Ï±ÑÌåÖÏóê ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄ ÌëúÏãú
    if (displayInChat) {
      const userMessage: ChatMessage = {
        id: uuidv4(),
        senderName: 'You',
        text: text,
        isUser: true
      };
      
      console.log('[sendMessage] ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄ Ï∂îÍ∞Ä:', userMessage);
      setMessages(prev => [...prev, userMessage]);
      
      // ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄ Ï†ÑÏÜ° ÌõÑ Ï¶âÏãú analyzing Î©îÏãúÏßÄ Ï∂îÍ∞Ä
      const analyzingMessages = [
        'ü§ñ Analyzing your request...',
        'üîç Processing your message...',
        '‚ö° Thinking about your request...',
        'üß† Understanding your needs...',
        'üí≠ Analyzing blockchain data...'
      ];
      
      const randomMessage = analyzingMessages[Math.floor(Math.random() * analyzingMessages.length)];
      
      const analyzingMessage: ChatMessage = {
        id: uuidv4(),
        senderName: 'LootPang Agent',
        text: randomMessage,
        isUser: false,
        isAnalyzing: true
      };
      
      console.log('[sendMessage] Analyzing Î©îÏãúÏßÄ Ï∂îÍ∞Ä:', analyzingMessage);
      setMessages(prev => [...prev, analyzingMessage]);
    }

    // Î©îÏãúÏßÄ Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞
    const messageData = {
      text: text,
      roomId: roomId.current,
      userId: walletAddress
    };

    console.log('[sendMessage] Ï†ÑÏÜ°Ìï† Îç∞Ïù¥ÌÑ∞:', messageData);
    socketRef.current.emit('message', messageData);
  };

  // ÏÜåÏºì Ïó∞Í≤∞ Î∞è Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
  useEffect(() => {
    console.log('[useEffect] ÏÜåÏºì Ïó∞Í≤∞ ÏÑ§Ï†ï ÏãúÏûë');
    
    // ÏÜåÏºì Ïó∞Í≤∞
    socketRef.current = io(BACKEND_URL, {
      transports: ['websocket'],
      autoConnect: true
    });

    const socket = socketRef.current;

    // Ïó∞Í≤∞ Ïù¥Î≤§Ìä∏
    socket.on('connect', () => {
      console.log('[socket] Ïó∞Í≤∞Îê®:', socket.id);
      setIsConnected(true);
      
      // Î£∏ Ï∞∏Ïó¨
      console.log(`[socket] Î£∏ Ï∞∏Ïó¨: ${roomId.current}`);
      socket.emit('join', roomId.current);
    });

    // Ïó∞Í≤∞ Ìï¥Ï†ú Ïù¥Î≤§Ìä∏
    socket.on('disconnect', () => {
      console.log('[socket] Ïó∞Í≤∞ Ìï¥Ï†úÎê®');
      setIsConnected(false);
    });

    // Î©îÏãúÏßÄ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ ÏàòÏã†
    socket.on('messageBroadcast', (data: any) => {
      console.log('[messageBroadcast] Î©îÏãúÏßÄ ÏàòÏã†:', data);
      
      try {
        const agentMessage: ChatMessage = {
          id: data.id || uuidv4(),
          senderName: 'LootPang Agent',
          text: data.text || 'Message received.',
          isUser: false,
          action: data.action,
          dataToSign: data.dataToSign
        };
        
        console.log('[messageBroadcast] ÏóêÏù¥Ï†ÑÌä∏ Î©îÏãúÏßÄ Ï∂îÍ∞Ä:', agentMessage);
        
        // analyzing Î©îÏãúÏßÄÎ•º Ïã§Ï†ú ÏùëÎãµÏúºÎ°ú ÍµêÏ≤¥
        setMessages(prev => {
          // ÎßàÏßÄÎßâ Î©îÏãúÏßÄÍ∞Ä analyzing Î©îÏãúÏßÄÏù∏ÏßÄ ÌôïÏù∏
          const lastMessage = prev[prev.length - 1];
          if (lastMessage && lastMessage.isAnalyzing) {
            // analyzing Î©îÏãúÏßÄÎ•º Ïã§Ï†ú ÏùëÎãµÏúºÎ°ú ÍµêÏ≤¥
            return [...prev.slice(0, -1), agentMessage];
          } else {
            // analyzing Î©îÏãúÏßÄÍ∞Ä ÏóÜÏúºÎ©¥ Í∑∏ÎÉ• Ï∂îÍ∞Ä
            return [...prev, agentMessage];
          }
        });
        
      } catch (error) {
        console.error('[messageBroadcast] Î©îÏãúÏßÄ Ï≤òÎ¶¨ Ïò§Î•ò:', error);
      }
    });

    // ÏóêÎü¨ Ïù¥Î≤§Ìä∏
    socket.on('error', (error: any) => {
      console.error('[socket] Error:', error);
      alert(`Server error: ${error.message || 'Unknown error'}`);
    });

    // Ïó∞Í≤∞ ÏóêÎü¨ Ïù¥Î≤§Ìä∏
    socket.on('connect_error', (error: any) => {
      console.error('[socket] Ïó∞Í≤∞ ÏóêÎü¨:', error);
      setIsConnected(false);
    });

    // Ï†ïÎ¶¨ Ìï®Ïàò
    return () => {
      console.log('[useEffect] ÏÜåÏºì Ïó∞Í≤∞ Ï†ïÎ¶¨');
      socket.disconnect();
    };
  }, []);

  // Ï¥àÍ∏∞ ÌôòÏòÅ Î©îÏãúÏßÄ Î∞è ÏßÄÍ∞ë Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
  useEffect(() => {
    if (messages.length === 0) {
      const welcomeMessage: ChatMessage = {
        id: uuidv4(),
        senderName: 'LootPang Agent',
        text: `üåü **Welcome to LootPang Cross-Chain Lending!** üåü

I'm your quest completion assistant! Here's how I can help you:

üîó **Cross-Chain Lending System:**
‚Ä¢ Use **Sepolia ETH** as collateral
‚Ä¢ Borrow **KK Tokens** on **Base Sepolia** network
‚Ä¢ Complete quests and earn rewards!

üí∞ **Lending Requirements:**
‚Ä¢ **1 KK Token** requires **~0.01 ETH** collateral
‚Ä¢ **10 KK Tokens** requires **~0.1 ETH** collateral
‚Ä¢ **100 KK Tokens** requires **~1.0 ETH** collateral

üöÄ **Getting Started:**
1. Connect your wallet (top-right button)
2. Try: \`deposit 0.1 eth\` to add collateral
3. Then: \`borrow 10 kkcoin\` to get tokens
4. Complete quests to earn rewards!

üí° **Quick Commands:**
‚Ä¢ \`deposit [amount] eth\` - Add collateral
‚Ä¢ \`borrow [amount] kkcoin\` - Request loan
‚Ä¢ \`status\` - Check your loan status

Ready to start your quest journey? üéØ`,
        isUser: false
      };
      
      setMessages([welcomeMessage]);
    }

    // Ïù¥ÎØ∏ Ïó∞Í≤∞Îêú ÏßÄÍ∞ëÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
    const checkExistingWallet = async () => {
      if (typeof window.ethereum !== 'undefined') {
        try {
          const provider = new ethers.BrowserProvider(window.ethereum);
          const accounts = await provider.listAccounts();
          
          if (accounts.length > 0) {
            const signerInstance = await provider.getSigner();
            const address = await signerInstance.getAddress();
            
            setSigner(signerInstance);
            setWalletAddress(address);
            
            console.log(`[checkExistingWallet] Existing wallet connection detected: ${address}`);
          }
        } catch (error) {
          console.log('[checkExistingWallet] No existing wallet connection:', error);
        }
      }
    };

    checkExistingWallet();
  }, []);

  return { 
    messages, 
    isConnected, 
    connectWallet, 
    sendMessage, 
    walletAddress,
    switchToBaseNetwork
  };
} 